#############################################################################
 #
 #  This file is part of Verkko, a software program that assembles
 #  whole-genome sequencing reads into telomere-to-telomere
 #  haplotype-resolved chromosomes.
 #
 #  Except as indicated otherwise, this is a 'United States Government
 #  Work', and is released in the public domain.
 #
 #  File 'README.licenses' in the root directory of this distribution
 #  contains full conditions and disclaimers.
 #
 ##

#
#  Rule buildGraph uses MBG to build an initial assembly graph from the input
#  HiFi reads.
#  
#    MBG: Minimizer-based sparse de Bruijn Graph construction
#    Mikko Rautiainen, Tobias Marschall
#    Bioinformatics, Volume 37, Issue 16, 15 August 2021, Pages 2476â€“2478
#    https://doi.org/10.1093/bioinformatics/btab004
#
#  Configuration Parameters
#    mbg_baseK
#    mbg_maxK
#    mbg_window
#
#  input.reads is either the output of the correction stage or the list of
#  raw HiFi reads, depending on if --no-correction is supplied to verkko.sh.
#

def toFloat(val):
    return float(val)

rule buildGraph:
    input:
        reads     = {rules.correctHiFi.output.fasta} if config['correction_enabled'] == "True" else HIFI_READS,
    output:
        graph     = '1-buildGraph/hifi-resolved.gfa',
        hificov   = '1-buildGraph/hifi_nodecov.csv',
        paths     = '1-buildGraph/paths.gaf'
    log:
        err       = '1-buildGraph/buildGraph.err'
    params:
        MBG       = config['MBG'],
        corenable = config['correction_enabled'],

        baseK             = config['mbg_baseK'],
        maxK              = config['mbg_maxK'],
        window            = config['mbg_window'],
        maxR              = config['mbg_max_resolution'],
        kmer_abundance    = 1,                   #  MBG default = 1
        unitig_abundance  = 2                    #  MBG default = 2
    threads:
        int(config['mbg_n_cpus'])
    resources:
        job_id = 1,
        n_cpus = config['mbg_n_cpus'],
        mem_gb = lambda wildcards, input, attempt: getMBGMemoryRequest(attempt),
        time_h = lambda wildcards, input, attempt: getTimeRequest(attempt, 'mbg')
    shell:
        '''
cd 1-buildGraph

cat > ./buildGraph.sh <<EOF
#!/bin/sh
set -e

#  Figure out what reads we're going to use.  If correction is enabled, the
#  reads are in a single file that is a relative path away from us; but if it
#  is not enabled, the reads are in possibly multiple files that are at an
#  absolute path.
#
iopt=""

echo "Building graph with reads:"

if [ "{params.corenable}" = "True" ] ; then
  echo "  ../{input.reads}"
  iopt="-i ../{input.reads}"
else
  for rf in {HIFI_READS} ; do
    echo "  \$rf"
    iopt="\$iopt -i \$rf"
  done
fi

echo ""
echo ""

#  Build the graph.
#    (rule build_graph in the original)
#
{params.MBG} \\\\
  \$iopt \\\\
  -t {resources.n_cpus} \\\\
  -k {params.baseK} \\\\
  -r {params.maxK} -R {params.maxR} \\\\
  -w {params.window} \\\\
  --kmer-abundance {params.kmer_abundance} \\\\
  --unitig-abundance {params.unitig_abundance} \\\\
  --error-masking=collapse-msat \\\\
  --output-sequence-paths ../{output.paths} \\\\
  --out ../{output.graph}

#  Find coverage.
#    (rule hifi_coverage_csv in the original Snakefile)
#    (hifi-resolved.gfa -> hifi_nodecov.csv)
#    (\$6 != "" is from 9e31a602925a477a7e52c277eda143e7bd20e52b)
#
awk 'BEGIN \\\\
     {{ \\\\
        FS="[ \\t]+"; OFS="\\t"; \\\\
        print "node", "length", "coverage"; \\\\
     }} \\\\
     \$1 == "S" \\\\
     {{ \\\\
        if (\$6 != "") {{
          \$4 = \$6;
        }}
        print \$2, length(\$3), substr(\$4, 6); \\\\
     }}' \\\\
< ../{output.graph} \\\\
> ../{output.hificov}
EOF

chmod +x ./buildGraph.sh

./buildGraph.sh > ../{log.err} 2>&1
        '''

